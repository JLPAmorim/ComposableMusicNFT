import {
  VList,
  VListItem,
  makeItemsProps,
  useItems
} from "./chunk-6HNGIMUW.js";
import {
  VMenu
} from "./chunk-2LUUCNGS.js";
import "./chunk-BBS2OB6C.js";
import "./chunk-A2BH7HCE.js";
import {
  VChip
} from "./chunk-B76H3FFP.js";
import "./chunk-IJH6W4AP.js";
import "./chunk-46FZBP4H.js";
import "./chunk-3WFSYMIM.js";
import "./chunk-EMWAU7P2.js";
import {
  VDefaultsProvider
} from "./chunk-7HSIRH4K.js";
import "./chunk-B2TUGICT.js";
import "./chunk-EGF5BYXV.js";
import {
  VCheckboxBtn
} from "./chunk-IRPUKQFC.js";
import "./chunk-CY4OO342.js";
import "./chunk-E5EUHXTA.js";
import "./chunk-VAPZVWY5.js";
import "./chunk-I7CTESEF.js";
import {
  VTextField
} from "./chunk-2O2GEUMA.js";
import "./chunk-RNTHOG2X.js";
import {
  forwardRefs
} from "./chunk-ABXCYA5O.js";
import "./chunk-NSKMY3Z4.js";
import "./chunk-GNPRYO77.js";
import "./chunk-X3N5T7L6.js";
import "./chunk-3GCU5YPE.js";
import {
  VDialogTransition
} from "./chunk-QWIJMVUU.js";
import "./chunk-3GIBJQAQ.js";
import "./chunk-C6DBG73R.js";
import "./chunk-OWLY3STX.js";
import "./chunk-4FFTLX3Z.js";
import "./chunk-V5UTOGC6.js";
import "./chunk-MOQFM4CJ.js";
import "./chunk-GJFEBRMM.js";
import {
  makeTransitionProps
} from "./chunk-2JT73ZJ2.js";
import {
  IconValue
} from "./chunk-63GZZJ3B.js";
import {
  useLocale
} from "./chunk-6OOBLR4Y.js";
import "./chunk-XMRKMW5L.js";
import {
  useProxiedModel
} from "./chunk-TZNIJ3XB.js";
import {
  genericComponent,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-RVNKJLVU.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  mergeProps,
  ref
} from "./chunk-UKT6457V.js";
import "./chunk-J43GMYXM.js";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "C:/Users/Joao/Desktop/ComposableMusicNFT/composableMusic/node_modules/vuetify/lib/components/VSelect/VSelect.css";
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  modelValue: null,
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  readonly: Boolean,
  ...makeItemsProps({
    itemChildren: false
  })
}, "select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const menu = useProxiedModel(props, "menu");
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      var _a;
      const transformed = transformOut(v);
      return props.multiple ? transformed : (_a = transformed[0]) != null ? _a : null;
    });
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => item.value === v.value) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const listRef = ref();
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length || props.readonly)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (props.readonly)
        return;
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "ArrowDown") {
        var _listRef$value;
        (_listRef$value = listRef.value) == null ? void 0 : _listRef$value.focus("next");
      } else if (e.key === "ArrowUp") {
        var _listRef$value2;
        (_listRef$value2 = listRef.value) == null ? void 0 : _listRef$value2.focus("prev");
      } else if (e.key === "Home") {
        var _listRef$value3;
        (_listRef$value3 = listRef.value) == null ? void 0 : _listRef$value3.focus("first");
      } else if (e.key === "End") {
        var _listRef$value4;
        (_listRef$value4 = listRef.value) == null ? void 0 : _listRef$value4.focus("last");
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => selection === item.value);
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _listRef$value5;
      if (!((_listRef$value5 = listRef.value) != null && _listRef$value5.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onFocusout(e) {
      if (e.relatedTarget == null) {
        var _vTextFieldRef$value;
        (_vTextFieldRef$value = vTextFieldRef.value) == null ? void 0 : _vTextFieldRef$value.focus();
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }, {
        ...slots,
        default: () => {
          var _slots$noData, _slots$prependItem, _slots$appendItem;
          return createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "eager": props.eager,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition
          }, props.menuProps), {
            default: () => [createVNode(VList, {
              "ref": listRef,
              "selected": selected.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e) => e.preventDefault(),
              "onFocusout": onFocusout
            }, {
              default: () => {
                var _a;
                return [!items.value.length && !props.hideNoData && ((_a = (_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) != null ? _a : createVNode(VListItem, {
                  "title": t(props.noDataText)
                }, null)), (_slots$prependItem = slots["prepend-item"]) == null ? void 0 : _slots$prependItem.call(slots), items.value.map((item, index) => {
                  var _a2;
                  var _slots$item;
                  return (_a2 = (_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
                    item,
                    index,
                    props: mergeProps(item.props, {
                      onClick: () => select(item)
                    })
                  })) != null ? _a2 : createVNode(VListItem, mergeProps({
                    "key": index
                  }, item.props, {
                    "onClick": () => select(item)
                  }), {
                    prepend: (_ref2) => {
                      let {
                        isSelected
                      } = _ref2;
                      return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                        "modelValue": isSelected,
                        "ripple": false
                      }, null) : void 0;
                    }
                  });
                }), (_slots$appendItem = slots["append-item"]) == null ? void 0 : _slots$appendItem.call(slots)];
              }
            })]
          }), selections.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            return createVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? createVNode(VDefaultsProvider, {
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slots.chip ? slots.chip({
                item,
                index,
                props: slotProps
              }) : createVNode(VChip, slotProps, null)]
            }) : slots.selection ? slots.selection({
              item,
              index
            }) : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        }
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});
export {
  VSelect
};
//# sourceMappingURL=vuetify_lib_components_VSelect_index__mjs.js.map
